# 小说查询增强功能设计文档

**版本**: v1.0
**设计日期**: 2026-02-18
**设计人**: OpenClaw
**状态**: 待评审

---

## 📋 目录

1. [需求分析](#1-需求分析)
2. [数据库设计](#2-数据库设计)
3. [API设计](#3-api设计)
4. [查询性能优化](#4-查询性能优化)
5. [前端界面设计](#5-前端界面设计)
6. [测试计划](#6-测试计划)
7. [开发计划](#7-开发计划)

---

## 1. 需求分析

### 1.1 功能需求

根据用户反馈，需要在现有小说查询接口的基础上，增加以下筛选条件：

| 序号 | 功能 | 描述 | 优先级 |
|------|------|------|--------|
| 1 | 按状态筛选 | 支持按小说状态（连载中、已完结、停更）筛选 | P0 |
| 2 | 按标签筛选 | 支持按标签筛选，标签从已有标签中选择，用户不能输入，暂时只能选择一个标签 | P0 |
| 3 | 按字数筛选 | 支持按字数范围筛选（如：100万字以下、100-300万字、300-500万字、500万字以上） | P0 |
| 4 | 排序方式 | 在现有"按更新时间降序"基础上，增加"按字数降序" | P0 |

### 1.2 现有功能分析

**当前支持的查询条件**：
- ✅ 分页查询
- ✅ 平台筛选
- ✅ 关键词搜索（标题/作者）

**当前接口**：
```
GET /api/crawler/novels/page?page=0&size=10&platform=ciweimao&keyword=修仙
```

**当前排序方式**：
- 默认：按最新更新时间降序（`latestUpdateTime DESC`）

### 1.3 非功能需求

1. **查询性能**：确保查询响应时间 < 500ms（数据量 < 10万条）
2. **用户体验**：筛选条件切换流畅，不需要刷新页面
3. **可扩展性**：设计支持未来新增筛选条件
4. **数据一致性**：标签列表从数据库动态获取，保持实时更新

---

## 2. 数据库设计

### 2.1 现有字段分析

**Novel 实体已有相关字段**：

| 字段 | 类型 | 描述 | 是否需要修改 |
|------|------|------|-------------|
| `status` | Integer | 状态：0-停更, 1-连载, 2-完结 | ❌ 不需要 |
| `tags` | String | 标签（JSON数组格式） | ❌ 不需要 |
| `wordCount` | Long | 总字数 | ❌ 不需要 |
| `latestUpdateTime` | LocalDateTime | 最新更新时间 | ❌ 不需要 |

**结论**：数据库表结构不需要修改，现有字段已满足需求。

### 2.2 索引设计

**当前索引**：
```sql
CREATE INDEX idx_platform ON t_novel(platform);
CREATE INDEX idx_title ON t_novel(title);
CREATE INDEX idx_author ON t_novel(author);
CREATE INDEX idx_update_time ON t_novel(latestUpdateTime);
CREATE INDEX idx_status ON t_novel(status);
```

**需要新增的索引**：
```sql
-- 标签索引（由于tags是JSON格式，需要使用函数索引）
CREATE INDEX idx_word_count ON t_novel(word_count);

-- 复合索引（平台 + 状态 + 字数）
CREATE INDEX idx_platform_status_word_count ON t_novel(platform, status, word_count);

-- 复合索引（状态 + 字数 + 更新时间）
CREATE INDEX idx_status_word_count_update_time ON t_novel(status, word_count, latestUpdateTime);
```

**索引设计原则**：
1. 单列索引用于单条件查询
2. 复合索引用于多条件组合查询
3. 索引字段顺序按照查询频率和区分度排列
4. 避免过度索引，影响写入性能

---

## 3. API设计

### 3.1 接口概述

**接口路径**：`GET /api/crawler/novels/page`

**设计原则**：
1. 保持向后兼容，新增参数使用可选方式
2. 参数命名清晰易懂
3. 参数类型和取值范围明确
4. 支持多条件组合查询

### 3.2 请求参数设计

| 参数 | 类型 | 必填 | 默认值 | 说明 | 可选值 |
|------|------|------|--------|------|--------|
| `page` | int | 否 | 0 | 页码（从0开始） | ≥ 0 |
| `size` | int | 否 | 10 | 每页数量 | 1-100 |
| `platform` | String | 否 | 无 | 平台筛选 | ciweimao, sf, ciyuanji |
| `keyword` | String | 否 | 无 | 关键词搜索 | 匹配标题/作者 |
| `status` | Integer | 否 | 无 | 状态筛选 | 0-停更, 1-连载, 2-完结 |
| `tags` | String | 否 | 无 | 标签筛选（单选） | 动态获取 |
| `wordCountMin` | String | 否 | 无 | 最小字数（全部/10w/30w/50w/100w/200w） | - |
| `wordCountMax` | String | 否 | 无 | 最大字数（全部/10w/30w/50w/100w/200w） | - |
| `sortBy` | String | 否 | `updateTime` | 排序字段 | `updateTime`, `wordCount` |
| `sortOrder` | String | 否 | `desc` | 排序方向 | `asc`, `desc` |

### 3.3 参数组合示例

**示例1：所有筛选条件**
```http
GET /api/crawler/novels/page?page=0&size=20&platform=ciweimao&keyword=修仙&status=1&tags=玄幻&wordCountMin=10w&wordCountMax=200w&sortBy=wordCount&sortOrder=desc
```

**示例2：仅最小字数**
```http
GET /api/crawler/novels/page?wordCountMin=10w
```

**示例3：仅最大字数**
```http
GET /api/crawler/novels/page?wordCountMax=200w
```

**示例4：字数范围（10w-200w）**
```http
GET /api/crawler/novels/page?wordCountMin=10w&wordCountMax=200w
```

**示例2：仅状态筛选**
```http
GET /api/crawler/novels/page?status=1
```

**示例3：标签 + 字数范围**
```http
GET /api/crawler/novels/page?tags=玄幻&wordCountMin=1000000
```

**示例4：按字数降序排序**
```http
GET /api/crawler/novels/page?sortBy=wordCount&sortOrder=desc
```

### 3.4 响应格式

**响应字段保持不变**：
```json
{
  "content": [
    {
      "id": 1,
      "platform": "ciweimao",
      "novelId": "100466055",
      "title": "修仙从系统开始",
      "author": "逍遥子",
      "description": "一个修仙的故事",
      "coverUrl": "https://example.com/cover.jpg",
      "latestChapterTitle": "第100章",
      "tags": "[\"玄幻\", \"修仙\"]",
      "wordCount": 1500000,
      "latestUpdateTime": "2026-02-18T10:00:00",
      "status": 1,
      "createdAt": "2026-02-15T10:00:00",
      "updatedAt": "2026-02-18T10:00:00"
    }
  ],
  "totalElements": 100,
  "totalPages": 10,
  "size": 10,
  "number": 0
}
```

### 3.5 新增接口：获取可选标签列表

为了实现"标签从已有标签中选择，用户不能输入"，需要新增一个接口返回所有可用的标签。

**接口路径**：`GET /api/crawler/novels/tags`

**请求参数**：
- `platform`（可选）：按平台筛选标签

**响应格式**：
```json
{
  "success": true,
  "tags": [
    {
      "name": "玄幻",
      "count": 1250
    },
    {
      "name": "修仙",
      "count": 980
    },
    {
      "name": "穿越",
      "count": 856
    }
  ]
}
```

**字段说明**：
- `name`: 标签名称
- `count`: 该标签的小说数量

**排序规则**：
- 按小说数量降序排序（count DESC）
- 返回前100个标签

---

## 4. 查询性能优化

### 4.1 查询策略

#### 4.1.1 分层查询策略

根据查询条件的复杂度，采用分层查询策略：

**第一层：简单查询（单条件）**
```java
// 仅状态筛选
WHERE status = ? AND deleted = 0

// 仅字数筛选
WHERE word_count >= ? AND word_count <= ? AND deleted = 0

// 仅标签筛选
WHERE tags LIKE ? AND deleted = 0
```

**第二层：组合查询（2-3个条件）**
```java
// 状态 + 字数
WHERE status = ? AND word_count >= ? AND word_count <= ? AND deleted = 0

// 平台 + 标签
WHERE platform = ? AND tags LIKE ? AND deleted = 0

// 平台 + 状态 + 字数
WHERE platform = ? AND status = ? AND word_count >= ? AND word_count <= ? AND deleted = 0
```

**第三层：复杂查询（4个以上条件）**
```java
// 所有条件组合
WHERE platform = ?
  AND (title LIKE ? OR author LIKE ?)
  AND status = ?
  AND (tags LIKE ? OR tags LIKE ?)
  AND word_count >= ?
  AND word_count <= ?
  AND deleted = 0
ORDER BY latest_update_time DESC
LIMIT 10 OFFSET 0
```

#### 4.1.2 标签查询优化

**问题**：tags字段是JSON数组格式，无法直接使用索引。

**解决方案**：
1. **使用JSON函数查询**（MySQL 5.7+）：
```sql
-- 使用JSON_CONTAINS查询
WHERE JSON_CONTAINS(tags, '"玄幻"') AND deleted = 0

-- 使用JSON_SEARCH查询
WHERE JSON_SEARCH(tags, 'one', '玄幻') IS NOT NULL AND deleted = 0
```

2. **使用LIKE模糊查询**（兼容性强）：
```sql
-- 标签格式：["玄幻", "修仙"]
WHERE tags LIKE '%\"玄幻\"%' AND deleted = 0
```

3. **标签缓存方案**：
   - 在内存中缓存热门标签列表（Redis）
   - 定期刷新缓存（每5分钟）
   - 减少数据库查询次数

### 4.2 Repository查询方法设计

```java
/**
 * 分页查询小说（通用方法）
 */
Page<Novel> findByDeletedOrderByLatestUpdateTimeDesc(Integer deleted, Pageable pageable);

/**
 * 根据状态分页查询
 */
Page<Novel> findByStatusAndDeletedOrderByLatestUpdateTimeDesc(Integer status, Integer deleted, Pageable pageable);

/**
 * 根据状态和字数范围分页查询
 */
Page<Novel> findByStatusAndWordCountBetweenAndDeletedOrderByLatestUpdateTimeDesc(
    Integer status, Long minWordCount, Long maxWordCount, Integer deleted, Pageable pageable);

/**
 * 根据平台、状态和字数范围分页查询
 */
Page<Novel> findByPlatformAndStatusAndWordCountBetweenAndDeletedOrderByLatestUpdateTimeDesc(
    String platform, Integer status, Long minWordCount, Long maxWordCount, Integer deleted, Pageable pageable);

/**
 * 复杂查询（支持多条件组合）
 */
@Query("SELECT n FROM Novel n WHERE n.deleted = 0 " +
       "AND (:platform IS NULL OR n.platform = :platform) " +
       "AND (:keyword IS NULL OR n.title LIKE %:keyword% OR n.author LIKE %:keyword%) " +
       "AND (:status IS NULL OR n.status = :status) " +
       "AND (:tags IS NULL OR n.tags LIKE %:tags%) " +
       "AND (:wordCountMin IS NULL OR n.wordCount >= :wordCountMin) " +
       "AND (:wordCountMax IS NULL OR n.wordCount <= :wordCountMax) " +
       "ORDER BY " +
       "CASE WHEN :sortBy = 'wordCount' AND :sortOrder = 'asc' THEN n.wordCount END ASC, " +
       "CASE WHEN :sortBy = 'wordCount' AND :sortOrder = 'desc' THEN n.wordCount END DESC, " +
       "CASE WHEN :sortBy = 'updateTime' AND :sortOrder = 'asc' THEN n.latestUpdateTime END ASC, " +
       "CASE WHEN :sortBy = 'updateTime' AND :sortOrder = 'desc' THEN n.latestUpdateTime END DESC")
Page<Novel> searchNovels(
    @Param("platform") String platform,
    @Param("keyword") String keyword,
    @Param("status") Integer status,
    @Param("tags") String tags,
    @Param("wordCountMin") Long wordCountMin,
    @Param("wordCountMax") Long wordCountMax,
    @Param("sortBy") String sortBy,
    @Param("sortOrder") String sortOrder,
    Pageable pageable);

/**
 * 获取所有标签（按数量降序）
 */
@Query(value = "SELECT JSON_UNQUOTE(JSON_EXTRACT(tags, CONCAT('$[', seq.seq, ']'))) as tag_name, " +
               "COUNT(*) as tag_count " +
               "FROM t_novel, " +
               "(SELECT 0 AS seq UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) seq " +
               "WHERE JSON_LENGTH(tags) > seq.seq " +
               "AND deleted = 0 " +
               "GROUP BY tag_name " +
               "ORDER BY tag_count DESC " +
               "LIMIT 100", nativeQuery = true)
List<Map<String, Object>> getAllTags();

/**
 * 根据平台获取标签（按数量降序）
 */
@Query(value = "SELECT JSON_UNQUOTE(JSON_EXTRACT(tags, CONCAT('$[', seq.seq, ']'))) as tag_name, " +
               "COUNT(*) as tag_count " +
               "FROM t_novel, " +
               "(SELECT 0 AS seq UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) seq " +
               "WHERE platform = :platform " +
               "AND JSON_LENGTH(tags) > seq.seq " +
               "AND deleted = 0 " +
               "GROUP BY tag_name " +
               "ORDER BY tag_count DESC " +
               "LIMIT 100", nativeQuery = true)
List<Map<String, Object>> getTagsByPlatform(@Param("platform") String platform);
```

### 4.3 缓存策略

#### 4.3.1 标签列表缓存

**缓存键设计**：
- `novel:tags:all` - 所有标签列表
- `novel:tags:platform:{platform}` - 指定平台的标签列表

**缓存内容**：
```json
{
  "tags": [
    {"name": "玄幻", "count": 1250},
    {"name": "修仙", "count": 980}
  ],
  "updatedAt": "2026-02-18T10:00:00"
}
```

**缓存策略**：
- **缓存时间**: 1小时（3600秒）
- **刷新策略**: 定时任务每1小时刷新一次
- **失效策略**: 手动刷新（当需要立即更新时）
- **缓存位置**: 本地缓存（不使用Redis）

#### 4.3.2 查询结果缓存

**适用场景**：
- 固定条件查询（如：状态=1，排序= updateTime DESC）
- 热门查询（如：最新更新的小说列表）

**缓存键设计**：
```
novel:list:platform={platform}:status={status}:tags={tags}:wordCountMin={min}:wordCountMax={max}:sortBy={sortBy}:sortOrder={order}:page={page}:size={size}
```

**缓存时间**: 2分钟

### 4.4 查询性能预估

| 数据量 | 查询条件 | 索引使用 | 预估耗时 |
|--------|---------|---------|---------|
| 1万条 | 单条件（状态） | ✅ idx_status | < 50ms |
| 1万条 | 组合条件（状态+字数） | ✅ idx_status_word_count | < 80ms |
| 1万条 | 复杂查询（4+条件） | ✅ 复合索引 | < 150ms |
| 10万条 | 单条件（状态） | ✅ idx_status | < 100ms |
| 10万条 | 组合条件（状态+字数） | ✅ idx_status_word_count | < 200ms |
| 10万条 | 复杂查询（4+条件） | ⚠️ 复合索引 | < 500ms |

---

## 5. 前端界面设计

### 5.1 参考界面

**用户提供的界面参考图**：
- 顶部搜索框
- 筛选条件横向排列（平台、状态、字数、排序）
- 标签筛选，显示已选标签
- 小说卡片列表展示

**界面截图参考**：见用户提供的界面图

### 5.2 界面布局

```
┌─────────────────────────────────────────────────────────────┐
│  小说列表                        [搜索框] [搜索按钮]          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  筛选条件                                                      │
│                                                               │
│  平台: [全部] [刺猬猫] [起点] [SF] [次元姬]                   │
│                                                               │
│  状态: [全部] [连载中] [已完结] [停更]                        │
│                                                               │
│  字数: 最小[全部] [10w] [30w] [50w] [100w] [200w] 最大[全部] [10w] [30w] [50w] [100w] [200w] │
│                                                               │
│  排序: [更新时间↓] [字数↓]                                    │
│                                                               │
│  标签: [全部] [玄幻] [修仙] [穿越] [都市] [系统] [重生] ...  │
│       (横向滚动显示更多标签)                                  │
│                                                               │
│  ─────────────────────────────────────────────────────────   │
│                                                               │
│  小说列表 (共100条)                          第1/10页 [>][>>]│
│                                                               │
│  ┌────┐ ┌────┐ ┌────┐ ┌────┐                             │
│  │封面│ │封面│ │封面│ │封面│                             │
│  └────┘ └────┘ └────┘ └────┘                             │
│  标题       作者       字数    状态        更新时间         │
│  标题       作者       字数    状态        更新时间         │
│  标题       作者       字数    状态        更新时间         │
│  标题       作者       字数    状态        更新时间         │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 5.3 筛选组件设计

根据用户反馈，不使用下拉框，使用按钮组样式。

#### 5.3.1 平台筛选

**组件类型**：按钮组（横向排列）

**选项**：
- 全部（默认选中）
- 刺猬猫
- 起点
- SF轻小说
- 次元姬

**样式**：
- 选中：蓝色背景，白色文字
- 未选中：灰色背景，深色文字
- 鼠标悬停：浅灰色背景

#### 5.3.2 状态筛选

**组件类型**：按钮组（横向排列）

**选项**：
- 全部（默认选中）
- 连载中
- 已完结
- 停更

**样式**：
- 与平台筛选保持一致的样式

**状态值映射**：
- 连载中 = 1
- 已完结 = 2
- 停更 = 0

#### 5.3.3 字数筛选

**组件类型**：按钮组（横向排列，两个筛选器）

**选项**：

**最小字数**（可选）：
- 全部（默认选中）
- 10w
- 30w
- 50w
- 100w
- 200w

**最大字数**（可选）：
- 全部（默认选中）
- 10w
- 30w
- 50w
- 100w
- 200w

**样式**：
- 与平台筛选保持一致的样式

**字数范围映射**：

**最小字数**：
- 全部 = 无限制（不限制最小值）
- 10w = 100,000（字数 >= 100,000）
- 30w = 300,000（字数 >= 300,000）
- 50w = 500,000（字数 >= 500,000）
- 100w = 1,000,000（字数 >= 1,000,000）
- 200w = 2,000,000（字数 >= 2,000,000）

**最大字数**：
- 全部 = 无限制（不限制最大值）
- 10w = 100,000（字数 <= 100,000）
- 30w = 300,000（字数 <= 300,000）
- 50w = 500,000（字数 <= 500,000）
- 100w = 1,000,000（字数 <= 1,000,000）
- 200w = 2,000,000（字数 <= 2,000,000）

**组合示例**：
- 最小字数=10w，最大字数=全部：字数 >= 100,000
- 最小字数=全部，最大字数=200w：字数 <= 2,000,000
- 最小字数=10w，最大字数=200w：100,000 <= 字数 <= 2,000,000
- 最小字数=全部，最大字数=全部：无限制

#### 5.3.4 标签筛选

**组件类型**：横向滚动的标签列表（单选）

**特性**：
- 从后端获取标签列表
- 标签横向排列，支持左右滚动
- 最多显示10个标签，其余可滚动查看
- 选中：蓝色背景，白色文字
- 未选中：浅灰色背景，深色文字
- 鼠标悬停：浅灰色背景
- 暂时只能选择一个标签
- 标签显示小说数量

**标签格式**：
```
全部 玄幻(1250) 修仙(980) 穿越(856) 都市(723) 系统(654) 重生(521) ...
```

**默认值**：全部（未选择标签）

**滚动方式**：
- 鼠标滚轮
- 左右箭头按钮
- 触摸滑动（移动端）

#### 5.3.5 排序方式

**组件类型**：按钮组（横向排列）

**选项**：
- 更新时间↓（默认选中）
- 更新时间↑
- 字数↓
- 字数↑

**样式**：
- 与平台筛选保持一致的样式
- 显示排序图标（↑/↓）表示方向

**排序值映射**：
- 更新时间↓ = updateTime, desc
- 更新时间↑ = updateTime, asc
- 字数↓ = wordCount, desc
- 字数↑ = wordCount, asc

### 5.4 交互设计

#### 5.4.1 实时筛选

**触发方式**：
- 点击按钮后立即触发查询（无需确认按钮）
- 防抖处理：延迟500ms后触发，避免频繁请求

**加载状态**：
- 显示加载动画
- 禁用筛选控件（防止重复点击）

#### 5.4.2 标签选择

**交互流程**：
1. 页面加载时，自动获取标签列表（带数量）
2. 标签横向排列，支持滚动
3. 点击标签立即筛选
4. 选中标签高亮显示
5. 点击"全部"清除标签筛选

**用户体验**：
- 标签按小说数量降序排序
- 标签数量显示在括号内
- 选中标签高亮显示
- 标签列表自动缓存（1小时）
- 滚动流畅，无卡顿

#### 5.4.3 按钮组交互

**选中效果**：
- 背景色：#409EFF（蓝色）
- 文字色：#FFFFFF（白色）
- 阴影：0 2px 4px rgba(64, 158, 255, 0.3)

**未选中效果**：
- 背景色：#F5F7FA（浅灰色）
- 文字色：#606266（深灰色）
- 鼠标悬停：背景色 #ECF5FF（浅蓝色）

**过渡动画**：
- 背景色过渡：0.3s ease
- 阴影过渡：0.3s ease

### 5.5 响应式设计

**桌面端（>1024px）**：
- 筛选条件横向排列，一行显示一个类型
- 标签横向滚动
- 小说列表4列显示

**平板端（768px - 1024px）**：
- 筛选条件横向排列，一行显示一个类型
- 标签横向滚动
- 小说列表2列显示

**移动端（<768px）**：
- 筛选条件竖向排列
- 标签横向滚动（保持原样）
- 小说列表1列显示
- 按钮组紧凑样式（间距缩小）

### 5.6 样式设计

#### 5.6.1 按钮组样式

```css
/* 按钮组容器 */
.filter-group {
  display: flex;
  gap: 8px;
  flex-wrap: nowrap;
  overflow-x: auto;
  padding: 8px 0;
}

/* 按钮样式 */
.filter-button {
  padding: 6px 16px;
  border: 1px solid #DCDFE6;
  border-radius: 4px;
  background-color: #F5F7FA;
  color: #606266;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
  white-space: nowrap;
}

.filter-button:hover {
  background-color: #ECF5FF;
  border-color: #409EFF;
  color: #409EFF;
}

.filter-button.active {
  background-color: #409EFF;
  border-color: #409EFF;
  color: #FFFFFF;
  box-shadow: 0 2px 4px rgba(64, 158, 255, 0.3);
}

/* 标签按钮特殊样式 */
.filter-button.tag {
  background-color: #F5F7FA;
  color: #606266;
}

.filter-button.tag:hover {
  background-color: #ECF5FF;
  color: #409EFF;
}

.filter-button.tag.active {
  background-color: #409EFF;
  color: #FFFFFF;
}
```

#### 5.6.2 标签滚动容器

```css
/* 标签滚动容器 */
.tags-container {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 8px 0;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
}

/* 隐藏滚动条 */
.tags-container::-webkit-scrollbar {
  display: none;
}

.tags-container {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

/* 滚动箭头按钮 */
.scroll-arrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.9);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 10;
}

.scroll-arrow.left {
  left: 0;
}

.scroll-arrow.right {
  right: 0;
}
```

---

## 6. 测试计划

### 6.1 单元测试

#### 6.1.1 Repository层测试

**测试类**：`NovelRepositoryTest`

**测试方法**：
```java
testFindByStatus()
testFindByStatusAndWordCountBetween()
testFindByPlatformAndStatusAndWordCountBetween()
testSearchNovels_AllParameters()
testSearchNovels_OnlyStatus()
testSearchNovels_OnlyTags()
testSearchNovels_SortByWordCount()
testGetAllTags()
testGetTagsByPlatform()
```

**测试数据准备**：
- 准备100条测试数据
- 覆盖所有状态（0, 1, 2）
- 覆盖不同字数范围
- 覆盖不同标签

#### 6.1.2 Controller层测试

**测试类**：`CrawlerControllerTest`

**测试方法**：
```java
testGetNovelsPage_AllParameters()
testGetNovelsPage_OnlyStatus()
testGetNovelsPage_OnlyTags()
testGetNovelsPage_SortByWordCount()
testGetNovelsPage_WrongStatus()
testGetNovelsPage_WrongWordCount()
testGetAllTags()
testGetTagsByPlatform()
```

### 6.2 集成测试

#### 6.2.1 查询性能测试

**测试场景**：
1. 单条件查询（状态）
2. 组合条件查询（状态+字数）
3. 复杂查询（所有条件）
4. 不同数据量下的查询性能

**性能指标**：
- 单条件查询 < 100ms
- 组合条件查询 < 200ms
- 复杂查询 < 500ms

#### 6.2.2 缓存测试

**测试场景**：
1. 标签列表缓存命中
2. 标签列表缓存失效
3. 标签列表缓存刷新

### 6.3 接口测试

**测试工具**：Postman / JMeter

**测试用例**：
1. 正常查询（所有参数）
2. 部分参数查询
3. 无参数查询
4. 参数校验（错误的status、错误的wordCount）
5. 排序测试（按字数降序、按字数升序）
6. 分页测试（第1页、第10页、最后一页）

### 6.4 前端测试

**测试场景**：
1. 筛选条件切换是否正常
2. 标签选择是否正常
3. 排序切换是否正常
4. 分页功能是否正常
5. 响应式布局是否正常

---

## 7. 开发计划

### 7.1 开发任务分解

#### 第一阶段：后端开发（预计3-4小时）

| 任务 | 工作量 | 优先级 |
|------|--------|--------|
| NovelRepository新增查询方法 | 1.5h | P0 |
| CrawlerController更新接口 | 1h | P0 |
| 新增TagsController | 0.5h | P0 |
| 数据库索引优化 | 0.5h | P0 |
| 单元测试编写 | 1.5h | P0 |
| API文档更新 | 0.5h | P1 |

**小计**：5.5小时

#### 第二阶段：前端开发（预计5-6小时）

| 任务 | 工作量 | 优先级 |
|------|--------|--------|
| 筛选组件开发（按钮组样式） | 2h | P0 |
| 标签横向滚动组件开发 | 2h | P0 |
| API接口调用更新 | 1h | P0 |
| 前端测试 | 1h | P1 |

**小计**：6小时

#### 第三阶段：联调测试（预计2-3小时）

| 任务 | 工作量 | 优先级 |
|------|--------|--------|
| 前后端联调 | 1.5h | P0 |
| 性能测试 | 1h | P0 |
| Bug修复 | 0.5h | P1 |

**小计**：3小时

### 7.2 开发时间线

| 日期 | 任务 | 预计完成时间 |
|------|------|-------------|
| Day 1 上午 | 后端Repository开发 | 2h |
| Day 1 下午 | 后端Controller开发 | 2h |
| Day 1 晚上 | 后端单元测试 | 2h |
| Day 2 上午 | 前端筛选组件开发（按钮组） | 3h |
| Day 2 下午 | 前端标签滚动组件开发 | 3h |
| Day 2 晚上 | 前后端联调测试 | 2h |

**总计**：14小时（约2个工作日）

### 7.3 风险评估

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|---------|
| 标签查询性能不达标 | 高 | 中 | 使用缓存，优化SQL查询 |
| 前端组件开发超时 | 中 | 中 | 使用现成组件库（Element Plus）|
| 多条件组合查询性能差 | 高 | 低 | 优化索引，使用缓存 |
| 标签列表动态获取失败 | 中 | 低 | 降级方案：使用固定的热门标签列表 |

---

## 8. 附录

### 8.1 字数范围选项

#### 最小字数选项

| 选项 | 字数范围 | 说明 |
|------|---------|------|
| 全部 | 无限制 | 不限制最小值 |
| 10w | >= 100,000 | 10万字及以上 |
| 30w | >= 300,000 | 30万字及以上 |
| 50w | >= 500,000 | 50万字及以上 |
| 100w | >= 1,000,000 | 100万字及以上 |
| 200w | >= 2,000,000 | 200万字及以上 |

#### 最大字数选项

| 选项 | 字数范围 | 说明 |
|------|---------|------|
| 全部 | 无限制 | 不限制最大值 |
| 10w | <= 100,000 | 10万字及以下 |
| 30w | <= 300,000 | 30万字及以下 |
| 50w | <= 500,000 | 50万字及以下 |
| 100w | <= 1,000,000 | 100万字及以下 |
| 200w | <= 2,000,000 | 200万字及以下 |

#### 组合示例

| 最小字数 | 最大字数 | 实际范围 |
|---------|---------|---------|
| 全部 | 全部 | 无限制 |
| 10w | 全部 | >= 100,000 |
| 全部 | 200w | <= 2,000,000 |
| 10w | 200w | 100,000 <= 字数 <= 2,000,000 |

### 8.2 状态选项

| 选项 | 状态值 | 说明 |
|------|--------|------|
| 全部 | null | 不筛选 |
| 连载中 | 1 | 正在更新 |
| 已完结 | 2 | 已完结 |
| 停更 | 0 | 停止更新 |

### 8.3 排序选项

| 选项 | sortBy | sortOrder | 说明 |
|------|--------|-----------|------|
| 更新时间（降序） | updateTime | desc | 默认 |
| 更新时间（升序） | updateTime | asc | - |
| 字数（降序） | wordCount | desc | 新增 |
| 字数（升序） | wordCount | asc | 新增 |

### 8.4 接口URL编码示例

**示例：标签筛选**
```http
# URL编码前
GET /api/crawler/novels/page?tags=玄幻

# URL编码后
GET /api/crawler/novels/page?tags=%E7%8E%84%E5%B9%BB
```

**示例：字数范围**
```http
# 最小字数 + 最大字数
GET /api/crawler/novels/page?wordCountMin=10w&wordCountMax=200w

# 仅最小字数
GET /api/crawler/novels/page?wordCountMin=10w

# 仅最大字数
GET /api/crawler/novels/page?wordCountMax=200w
```

---

## 9. 评审问题

### 9.1 需要确认的问题

1. **标签筛选逻辑**：✅ 已确认使用"包含任一标签"（OR），暂时只能选择一个标签

2. **字数范围**：✅ 已确认支持大于或者小于（最小字数 + 最大字数，可选10w/30w/50w/100w/200w）

3. **排序方式**：✅ 已确认支持按字数降序和升序排序

4. **标签数量限制**：✅ 已确认暂时只能选择一个标签

5. **标签列表刷新频率**：✅ 已确认1小时刷新一次，使用本地缓存

6. **界面组件**：✅ 已确认不使用下拉框，使用按钮组样式

### 9.2 技术选型

1. **标签查询**：使用LIKE模糊查询

2. **缓存方案**：使用本地缓存，不引入Redis

3. **前端组件库**：使用Element Plus（与现有项目保持一致）

4. **标签选择方式**：单选（暂时只能选择一个标签）

5. **界面展示方式**：按钮组样式，不使用下拉框

6. **字数范围**：支持大于或者小于（最小字数 + 最大字数，可选10w/30w/50w/100w/200w）

---

**文档状态**: 已评审通过 ✅  
**下次更新**: 开发完成后
